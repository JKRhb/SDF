start = sdf-alt-schema

;;; sdf-alt-schema: Alternative ODM SDF schema (work in progress 20200304)

sdf-alt-schema = {
 info: sdfinfo
 ? namespace: named<text>
 ? defaultNamespace: text
 ? odmObject: named<obj-props>
 ? odmThing: sdfthing
 ? odmProperty: named<afford-props>
 ? odmAction: named<afford-props>
 ? odmEvent: named<afford-props>
}

sdfinfo = {
 title: text
 version: text
 copyright: text
 license: text
}

; Shortcut for a map that gives names to instances of X
named<X> = { * text => X }

sdfthing = {
 ? odmObject: named<obj-props>
 ? odmThing: sdfthing
}

obj-props = {
 ? description: text
 ? name: text
 ? odmRequired: [* sdf-pointer]
 ? odmProperty: named<afford-props>
 ? odmAction: named<afford-props>
 ? odmEvent: named<afford-props>
}

allowed-types = number / text / bool / null
              / [* number] / [* text] / [* bool]

commonqualities = (
 ? description: text            ; long text (no constraints)
 ? label: text                  ; short text (no constraints); default to key
 ? $comment: text
 ? odmRef: sdf-pointer
 ? odmRequired: [* sdf-pointer]
)

afford-props = dataqualities

dataqualities = {               ; also propertyqualities
 commonqualities,
 jsonschema,
 ? name: text                   ; DELETE ME
 ? units: text
 ? scaleMinimum: number
 ? scaleMaximum: number
 ? observable: bool
 ? readable: bool
 ? writable: bool
 ? nullable: bool
 ? widthInBits: number
 ? subtype: "bytestring" / "unixtime"
 ? contentFormat: text
}

jsonschema = (
 ? type: "number" / "string" / "boolean" / "integer" / "array" ; / "object"
 ? enum: [+ any]
 ? const: allowed-types
 ? default: allowed-types
 ; number constraints
 ? minimum: number
 ? maximum: number
 ? exclusiveMinimum: bool / number      ; jso draft 4/7
 ? exclusiveMaximum: bool / number      ; jso draft 4/7
 ; array constraints
 ? minItems: number
 ? maxItems: number
 ? uniqueItems: bool
 ; string constraints
 ? minLength: number
 ? maxLength: number
 ? items: { ;;; ultimately, this will be mostly recursive, but, for now
            ;;; let's find out what we actually need
     ; commonqualities, -- leaving this out for non-complex data types
     ? type: "number" / "string" / "boolean" / "integer" ; no "array" / "object"
     ; jso subset
     ? minimum: number
     ? maximum: number
     ? enum: [+ any]
     ? format: text
     ? minLength: number
     ? maxLength: number
   }
 ? pattern: text                ; regexp
 ? format: "date-time" / "date" / "time"
           / "uri" / "uri-reference" / "uuid"
           ; expand on demand
)

sdf-pointer = text .regexp curie

curie = ".*"; TODO URI REF

